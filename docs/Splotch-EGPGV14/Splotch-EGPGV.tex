 
\documentclass{egpubl}
\usepackage{pgv13}

% --- for  Annual CONFERENCE
% \ConferenceSubmission % uncomment for Conference submission
% \ConferencePaper      % uncomment for (final) Conference Paper
% \STAR                 % uncomment for STAR contribution
% \Tutorial             % uncomment for Tutorial contribution
% \ShortPresentation    % uncomment for (final) Short Conference Presentation
%
% --- for  CGF Journal
% \JournalSubmission    % uncomment for submission to Computer Graphics Forum
% \JournalPaper         % uncomment for final version of Journal Paper
%
% --- for  EG Workshop Proceedings
\WsSubmission    % uncomment for submission to EG Workshop
% \WsPaper         % uncomment for final version of EG Workshop contribution
%
 \electronicVersion % can be used both for the printed and electronic version

% for including postscript figures
% mind: package option 'draft' will replace PS figure by a filname within a frame
\ifpdf \usepackage[pdftex]{graphicx} \pdfcompresslevel=9
\else \usepackage[dvips]{graphicx} \fi

\PrintedOrElectronic

\usepackage{t1enc,dfadobe}

\usepackage{egweblnk}
\usepackage{cite}

\title[Visualization of Large Cosmological Data on Hybrid Systems]%
      {Visualization of Large Cosmological Data on Hybrid Systems}

% for anonymous conference submission please enter your SUBMISSION ID
% instead of the author's name (and leave the affiliation blank) !!
\author[M. Rivi \& C. Gheller \& T. Dykes \& I. Cant \& M. Krokos \& K. Dolag]
       {M. Rivi\thanks{Corresponding author}$^{1}$
        and C. Gheller$^{2}$ and T. Dykes$^{3}$ and I. Cant$^3$ and M. Krokos$^{3}$ and K. Dolag$^{4}$
        \\
         $^1$Department of Physics, University of Oxford, United Kingdom\\
         $^2$ETH-CSCS, Lugano, Switzerland\\
         $^3$School of Creative Technologies, University of Portsmouth, United Kingdom\\
         $^4$University Observatory Munich, Germany
       }

% ------------------------------------------------------------------------

% if the Editors-in-Chief have given you the data, you may uncomment
% the following five lines and insert it here
%
% \volume{27}   % the volume in which the issue will be published;
% \issue{1}     % the issue number of the publication
% \pStartPage{1}      % set starting page


%-------------------------------------------------------------------------
\begin{document}

% \teaser{
%  \includegraphics[width=\linewidth]{eg_new}
%  \centering
%   \caption{New EG Logo}
% \label{fig:teaser}
% }

\maketitle

\begin{abstract}
   The abstract may be up to 3 inches (7.62 cm) long.... 
%   Leave one blank line after the abstract, then add the subject categories according to the ACM Classification Index 

\begin{classification} % according to http://www.acm.org/class/1998/
\CCScat{Programming Techniques}{D.1.3}{Cuncurrent Programming}{Parallel programming}
\CCScat{Computer Graphics}{I.3.7}{Three-Dimensional Graphics and Realism}{Animation}
\CCScat{Simulation and Modeling}{I.6.3}{Applications}
\CCScat{Physical Sciences and Engineering}{J.2}{Astronomy}
\end{classification}

\end{abstract}

 
%-------------------------------------------------------------------------
\section{Introduction}

%-------------------------------------------------------------------------
\section{Splotch: a visualisation tool for astrophysical data}

Splotch is an open-source, pure C++ code for effectively visualizing large-scale, particle-based datasets. It was designed for visualising N-body and Smoothed Particles Hydrodynamics simulations where the data are particles represented by a Gaussian distribution with compact support. However it has also been efficiently used with data defined by regular or adaptive refined meshes by the development of readers able to convert them in the Splotch data type. Several readers are provided supporting a number of popular formats for astrophysics, e.g. HDF5, ...

The rendering algorithm is a derivate of what in general is called volume ray casting and uses an approximation of the radiative transfer equation
which, together with the application of perspective, gives the produced images a very realistic appearance. 

The main strengths of Splotch are high quality of images and the support for large data volumes through an optimised usage of HPC architectures. In fact a parallel version of the code combining the OpenMP and MPI programming paradigms allow to exploit multi-core and multi-node systems~\cite{JKR*10}. Moreover a CUDA version of the code is also available to accelerate the computation on GPUs~\cite{RGD*14}. 

Another important characteristic of this tool is its high level of customisation, through a parameter file, to suit specialised scientific dataset. To help the user in the fine tune of the parameters required by Splotch a Previewer tool is available (see Section~3).

%-------------------------------------------------------------------------
\subsection{Algorithm overview }

The operational scenario~\cite{DRGI08} consists in two main stages after reading particles from single or multiple data files . 
In the first stage, that we call \textit{rasterization}, a preprocessing step can perform ranging, normalization, and apply logarithms to particle attributes if required. Then particle coordinates and their \textit{smoothing length} $\sigma_p$ (i.e. the standard deviation of the gaussian distribution $\rho_p(x)$ describing the particle) are roto-translated, with reference to supplied camera and look-at positions, and projected according to a given field of view. Finally particles falling in the scene are identified and assigned with RGB colour values via a colour look-up table or palette (which can be provided as an external file).

The final stage is \textit{rendering}, where rays originating from each pixel of the image are cast along lines of sight, and contributions of all encountered particles are accumulated. The contribution of particles is determined by solving the radiative transfer equation:
\begin{equation}\label{rad}
 \frac{d I(x)}{dr}=( E_p- A_p I(x))\rho_p(x),
\end{equation}
where $I(x)$ is the colour intensity at position $x$, $E_p$ and $A_p$ describe the strength of radiation emission and absorption for a given particle for the three RGB colour component.

%-------------------------------------------------------------------------
\subsection{MPI+CUDA implementation}
The MPI implementation~\cite{JKR*10} simply distributes chunks of particles among different processors, each performing independently a serial computation and producing a partial rendering. The final image is composed by a collective reduction operation and saved only by the root processor.

By enabling the usage of GPUs, each MPI tasks executes the CUDA version of the code described in~\cite{RGD*14} to render its chunk of particles. 
Summarizing, each task transfers its data (or sub chunks of it a time if necessary) to the global GPU memory, then each particle is processed by the Rasterization kernel according to a one-thread-per-particle approach. Further this kernel classifies particles in three classes according to radius defined by
\begin{equation}
r(p) = A(p)\frac{\chi \sigma_p}{S_{box}}N_{pix} 
\end{equation}
where $A(p)$ is the factor of geometric projection to screen coordinates, $\chi$ is a factor of the order of unity, $\sigma_p$ is the smoothing length of the particle $p$, $N_{pix}$ is the image size in pixels, and $S_{box}$ represents the computational box size. Small particles with $r \le 0.5$ pixels can be efficiently handled by the GPU by assigning one particle per thread. Particles with $0.5 < r \le r_0$ ($r_0$ being an appropriate threshold assigned empirically) are processed by the GPU efficiently by exploiting a tiling based strategy: images are split into a number of tiles, each processed by a CUDA block treating only particles whose centre completely falls inside the tile. To be able to process all these medium particles, each block stores its tile in the shared memory with a boundary of $r_0$ pixels (creating an extended tile version) so that all particles assigned to individual tiles are completely contained. For each block particles are accessed in groups of elements, then rendered sequentially with a single parallel operation: each image pixel associated with a particle is processed by a different thread. When all particles of a block are rendered, the contribution of the tile and its boundary are added to the final image stored in the global memory, by taking particular care to the handling of overlapping regions. This prevents any concurrent memory access avoiding potential image artifacts. Finally, large particles ($r>r_0$) are asynchronously copied back to the CPU and processed concurrently with the GPU.
Once all calculations are completed, two partial images (one processed by the GPU the other by the CPU) are composed to generate the final rendering for each task. Such operation is performed by the CPU, once the GPU image has been transferred in a single copy operation.

This basic MPI+CUDA implementation requires each task exploiting a different GPU. However the HyperQ  feature (REF) provided by the Kepler architecture can be enabled allowing more tasks sharing the same device. In this case the chunks of particles to be transferred to the device by each task is resized according to the number of tasks per GPU.
%-------------------------------------------------------------------------
\section{Splotch Previewer}

Motivation, features and implementation.

%-------------------------------------------------------------------------
\section{Visualization of large scale structures of the Universe}
Movie description ....

\begin{itemize}
\item \textit {The dataset}: 
\item \textit {Visualization properties}: choice of the parameters describing colours, intensity (according to some scientific motivations?)
\item \textit {Geometrical setup and Animation}:  Sampling of the data to be investigated by the Previewer in order to prepare camera path and parameter file. Sampling 1 particle every 1000 is enough to have a realistic representation of the data distribution (see Figure~\ref{fig1:preview}). 
Notice that for some specific cases requiring a more accurate sampling, Splotch provides a feature called "booster" ( just few lines about the booster...).
Previewer usage to generate the camera path plotted in Figure~\ref{fig2:camera}. Number of frames and scene file description...
Usage of Splotch to generate final images. Figure~\ref{fig3:movie} shows ....
\end{itemize}

\begin{figure}[htb]
   
   \caption{\label{fig1:preview}
   Dataset visualisation by the Previewer.}
\end{figure}

\begin{figure}[htb]
   
   \caption{\label{fig2:camera}
   The geometrical setup of the camera path.}
\end{figure}

\begin{figure}[htb]
   
   \caption{\label{fig3:movie}
   A visualisation of .....}
\end{figure}
%-------------------------------------------------------------------------
\section{Performance Tests}

Platform description....

Scalability comparison between MPI and MPI+CUDA.

 

%-------------------------------------------------------------------------
\section{Conclusions}

 

%-------------------------------------------------------------------------

%\bibliographystyle{eg-alpha}
\bibliographystyle{eg-alpha-doi}

\bibliography{Splotch-EGPGV}



\end{document}
